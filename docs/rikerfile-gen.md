# End of Summer Report for Rikerfile Generation Project

**1. What was the goal for this task?** 

The goal was to lower the barrier of entry for using Riker. To do this, I implemented functionality to automatically generate Rikerfiles from existing Makefiles. I wanted the resulting Rikerfiles to be usable, able to run by `rkr`, but be more detailed than simply having a Rikerfile of `make --always-make`. I then intended to implement progressive improvements to the Rikerfile generator by processing the build commands, condensing the commands to make them more readable/performant. 


**2. Why is this useful?** 

Using Riker for a project holds many advantages, especially for larger projects where incremental builds can drastically improve the coding process through decreased build times. The problem is that, to use Riker, one needs a suitable Rikerfile, which can be quite involved to create by hand. This project intends to make it easy and simple to produce a Rikerfile for any project that already uses Makefiles to build the program. Instead of manually creating the Rikerfile, the user to run Riker with a simple `make --always-make` Rikerfile, generating a trace, then run `rkr generate` to create a usable and decent Rikerfile.


**3. How does your implementation work?** 

The implementation has 3 main steps. The first one is creating a simple Rikerfile, which involves creating a new file and traversing the trace (generated by running `rkr`) to populate the file with all make commands at the appropriate resolution (not too detailed). The second step is to process the generated Rikerfile, improving it through multiple means. This could involve formatting the commands/arguments, condensing the commands' flags with a `$CFLAGS` variable, or combining parallelizable complilation commands (not yet implemented). The third step is to finalize the Rikerfile by making it executable through `chmod u+x Rikerfile-gen`.

Condensing flags is the most complicated part of this project, and it involves progressively processing the commands until we can determine which flags are included in every compile command. We iterate over every command, first isolating compile commands, then isolating compile flags in each command. We then check every command for every flag previously identified, resulting in a 2D vector of booleans, where in one dimension we have the compile flags (in the order they were found), and the other dimension is each compile command. We then find each flag that is used for every compile command, and if there are 2 or more such flags, we replace them in each compile command with `$CFLAGS`. 


**4. Describe one or two examples that demonstrate the new functionality you added.** 

The main functionality of this project is that it adds a subcommand to Riker called generate. Upon running `rkr generate` in a project that alread has a Riker trace, a new Rikerfile is generated called `Rikerfile-gen`. This Rikerfile can then be run by `rkr` or directly executed to build the project. This assumes that the project is normally built using a Makefile, and that there is a Rikerfile invoking make used to generate the trace.
 

**5. Describe next steps for this task, if there are any.** 

While I successfully condensed common flags, I did not condense parallelize-able compile commands, which would have improved performance through the use of the compiler wrapper.

Additionally, the algorithm for condensing flags makes some assumptions for simplicity's sake, which could be improved with more time and thought. Particularly, the method for replacing flags with `$CFLAGS` could, instead of searching for a continuous string with the flags to be replaced, iterate through each argument of each command, removing the common flags and adding `$CFLAGS` as the first argument if all of them were found.

Finally, there are many potential edge cases that could be encountered by using `rkr generate` on a variety of projects.
