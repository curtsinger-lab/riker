# Fall 2021 Report

**1. What is the goal for this task?**

The goal is to lower the barrier of entry for using Riker. To do this, I implemented the ability to automatically generate Rikerfiles for projects with existing Makefiles. I wanted the resulting Rikerfiles to be runable as a list of shell commands on their own, and also be able to be run by rkr for its incremental build properties. I then added the ability to condense flags for compile commands, and eventually to condense compile commands themselves.

**2. Why is this useful?**

Using Riker for a project holds many advantages, especially for larger projects where incremental builds can drastically improve the coding process through decreased build times. The problem is that, to use Riker, one needs a suitable Rikerfile, which can be quite involved to create by hand. This project intends to make it easy and simple to produce a Rikerfile for any project that already uses Makefiles to build the program. Instead of manually creating the Rikerfile, the user can execute ./rkr generate which will create a file called Rikerfile-gen, the generated Rikerfile. The user can also pass in the --skip-condencing option (i.e. ./rkr generate --skip-condencing) to skip the compile condencing stage.

**3. How does your implementation work?**

The implementation has 3 main steps. The first one is creating a simple Rikerfile, which involves creating a new file and traversing the trace (generated by running rkr with make --always-make) to populate the file with all make commands at the appropriate resolution (not too detailed, else parent and child commands would both be recorded). 

The second step is to process the generated Rikerfile, improving it over multiple passthroughs. This began with calculating a variable $CFLAGS that pulls appropriate compile flags out of compile commands. This step was depricated when I implemented condensed compile commands, which matches compile commands with identical flags.

To condense compile commands, we first isolate commands in Rikerfile-gen that compile but do not link. We then match commands based on their flags (they must be identical) and the directories in which the source files are located and where the object file is compiled to. Once the commands are matched, we modify Rikerfile-gen to remove any grouped compile commands, replacing the last command of a group with the condensed one. One problem I encountered was that the -o flag cannot specify where multiple files will be compiled to. This requires the compiler to first cd to the compile location, then locate the source files and dependencies (-I flags) from this new location. While this solution is not perfect, requiring backtracking to first return to the original directory before finding source files and dependencies, it leads to successful compiling while maintaining the location of output files.

The third step is to finalize the Rikerfile, by running "chmod u+x Rikerfile-gen" to make give it permissions to be executed by the user. This command does not seem to work in practice, possibly because the command is executed in a new thread, so permissions are only changed in that environment.

**4. Describe one or two examples that demonstrate the new functionality you added.**

The main functionality of this project is that it adds a subcommand to Riker called generate. Upon running rkr generate in a project that alread has a Riker trace, a new Rikerfile is generated called Rikerfile-gen. This Rikerfile can then be run by rkr or directly executed to build the project. This assumes that the project is normally built using a Makefile, and that there is a Rikerfile invoking make used to generate the trace. By default, the subcommand will attempt to condense compile commands to take advantage of parallel compiling from the wrapper, but the option "--skip-condencing" can be passed to skip this step, allowing manual condencing/modifications.

**5. Describe next steps for this task, if there are any.**

The next steps for the project would be to improve the control flow of the program so it is more readable, particularly where I condense compiles in many steps of data processing. Additionally, I would put more time into benchmarking parallelized build time versus parallelization by Make. I confirmed that there is no overhead between unparallelized Make building and unparallelized Rikerfile-gen building, but I was unable to test parallelized Make builds with building using the compiler wrapper and condensed compiles. There is almost no overhead from changing directories for condensed compiles.

There are also still bugs in the code that need to be squashed. With some edge cases for directories, the condensed commands are not formatted correctly and must be manually changed. The code for condencing flags is also flawed, as its method for removing flags from a command involves string matching from the line, potentially removing matches that it shouldn't.