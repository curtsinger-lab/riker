The internal representation of a learned build is a directed graph where the vertices are labeled
by either a command to run (with arguments and environment variables) or a file (with a path,
modification time, and checksum). In addition, the command vertices may have an "opaque" flag and/or
an "out of date" flag, and some of the file vertices are marked as temporary and have a cached
version of the entire file. The edges of this graph are of two types, either execution edges running
from a parent command to a child command that it executes or dependency edges running between a file
and a command. The dependency edge goes from the input of a dependency to the output, that is, it either
runs from a file to a command that reads from that file or from a command to a file that is generated
by that command.

Graph invariants:
- As expressed above, the dependency edges only connect files to commands and vice versa, and
  execution edges only connect commands to other commands.
- Every command is executed by (i.e. pointed to via an execution edge) at most one other command. We
  refer to this other command as the first command's *parent*, and we reciprocally refer to the first
  command as the other command's *child*.
- Every file is generated by (i.e. pointed to via a dependency edge) at most one command. This does
  not mean that it is the only file with that path, as there may be other instances of the same file
  generated at different times by different commands.
- For any dependency cycles, then there exists some command vertex flagged "opaque" that is an ancestor
  of all the vertices involved in the cycle.

To rerun a build:
- Initialize a worklist to all command roots (those that do not have parents).
  - The command roots are also the seed build.
- Initialize a labeling of the vertices where every vertex is colored as either **changed**,
  **unchanged**, or **unknown**. All vertices start as **unknown**.
- For each command vertex that has an "out of date" flag, change its color to **changed**.
- For each file vertex that is not generated by any command, check to see if the modification time
  and checksum stored in the graph match the modification time and checksum on disk. If they do not
  match, then mark that vertex as **changed** and update the time and checksum in the graph.
  - The modification time is intended as an optimization over the checksum; if the modification time
    does not match, then we check the checksums for a change, but it the times do match, we assume
    that the file contents have not changed and don't need to rescan the file.
- Repeatedly take a command off of the worklist to run. Call this command the *current command*.
  - Note that this worklist is an unordered bag. Pieces of work can be removed in arbitrary order,
    possibly in parallel.
  - Some of the items in this worklist may not be ready to be run.
    - For a command to be ready, it must have all of its dependencies up to date. This means that all files
      that are read by a descendant of the command are either **changed**, **unchanged**, or written by
      another descendant of the command.
    - Additionally, when multiple files have the same name, we may be unable to run a command that writes one
      version of a file while another version still exists. This may also be solved by manipulating the
      filesystem to isolate commands and give them exactly the files they need.
- Test to see if there are any paths running from a **changed** node to the current command that
  - only consist of dependency edges, with no execution edges, and
  - never pass through an **unchanged** vertex.
- If not and the current command is not flagged as "opaque", then add all children of the current command
  to the worklist and go back to the beginning of the loop, starting a new piece of work.
- If so, then check whether there is some dependency chain running from the current command to one of the
  targets. If there is no such dependency, then flag the current command as "out of date" and go back to
  running work from the worklist.
- Run the current command, tracing it to reconstruct and rewrite the tree of descendandants.
- For each file written by the current command or one of its descendants, compare the checksums on disk to
  the checksums recorded in the graph. If the checksums match, then mark the corresponding file as **unchanged**,
  and if they do not match, then mark the corresponding file as **changed**.
  - If a file that was recorded as an output in the graph was not written, then it should also be marked as **unchanged**,
    but we may wish to emit a warning (though this can happen if the underlying command does incremental computation).
- Go back to complete a new piece of work.

Low level details:
- We store commands layed out linearly in a preorder traversal order with each command containing a number
  saying how many (recursive) descendants this command has execed. This is enough information to efficiently navigate
  the tree.
- Upon loading the on-disk graph, we immediately preprocess its tree of commands to allow for constant time Least Common
  Ancestor queries.
- We can precompute the number of input edges to each subtree. To do so, iterate through all dependency edges, and mark
  1 input to the subtree of the output and -1 outputs to the least common ancestor of the input's creator and output.
