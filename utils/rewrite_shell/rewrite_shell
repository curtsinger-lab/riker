#!/usr/bin/env python3
from typing import TYPE_CHECKING
from bashlex import parser, ast
from lib.pretty_printer import prettyprinter
import sys

env = {}

def my_methods(object):
    return [
        method_name
        for method_name in dir(object)
        if callable(getattr(object, method_name))
    ]


def gettypeinfo(tree):
    print(type(tree))
    print("METHODS\n" + str(my_methods(tree)))
    print("FIELDS\n" + str(vars(tree)))


class substitutionvisitor(ast.nodevisitor):
    def visitnode(self, n):
        return n

    def visitnodeend(self, n):
        return n

    def visitoperator(self, n, op):
        return n

    def visitlist(self, n, parts):
        return n

    def visitpipe(self, n, pipe):
        return n

    def visitpipeline(self, n, parts):
        return n

    def visitcompound(self, n, list, redirects):
        return n

    def visitif(self, n, parts):
        return n

    def visitfor(self, n, parts):
        return n

    def visitwhile(self, n, parts):
        return n

    def visituntil(self, n, parts):
        return n

    def visitcommand(self, n, parts):
        return n

    def visitfunction(self, n, name, body, parts):
        return n

    def visitword(self, n, word):
        # substitute the parameter from env
        if len(n.parts) == 1 and n.parts[0].kind == "parameter":
            word = env[n.parts[0].value]
            return ast.node(kind = "word", parts = [], pos = n.pos, word = word)
        if len(n.parts) > 1:
            raise sys.Error("WordNode has more than 1 part.")
        return n

    def visitassignment(self, n, word):
        # add entry to env
        [var, val] = word.split("=")
        env[var] = val
        return n

    def visitreservedword(self, n, word):
        return n

    def visitparameter(self, n, value):
        return n

    def visittilde(self, n, value):
        return n

    def visitredirect(self, n, input, type, output, heredoc):
        return n

    def visitheredoc(self, n, value):
        return n

    def visitprocesssubstitution(self, n, command):
        return n

    def visitcommandsubstitution(self, n, command):
        return n

    def visit(self, n):
        k = n.kind
        if k == "operator":
            return self._visitnode(n, n.op)
        elif k == "list":
            dochild = self._visitnode(n, n.parts)
            if dochild is None or dochild:
                for child in n.parts:
                    self.visit(child)
            # TODO
            return n
        elif k == "reservedword":
            return self._visitnode(n, n.word)
        elif k == "pipe":
            return self._visitnode(n, n.pipe)
        elif k == "pipeline":
            dochild = self._visitnode(n, n.parts)
            if dochild is None or dochild:
                for child in n.parts:
                    self.visit(child)
            # TODO
            return n
        elif k == "compound":
            dochild = self._visitnode(n, n.list, n.redirects)
            if dochild is None or dochild:
                for child in n.list:
                    self.visit(child)
                for child in n.redirects:
                    self.visit(child)
            # TODO
            return n
        elif k in ("if", "for", "while", "until"):
            dochild = self._visitnode(n, n.parts)
            if dochild is None or dochild:
                for child in n.parts:
                    self.visit(child)
            # TODO
            return n
        elif k == "command":
            dochild = self._visitnode(n, n.parts)
            if dochild is None or dochild:
                children = []
                for child in n.parts:
                    children.append(self.visit(child))
                # update arguments
                n2 = ast.node(kind = "command", parts = children, pos = n.pos)
                return n2
            # TODO
            return n
        elif k == "function":
            dochild = self._visitnode(n, n.name, n.body, n.parts)
            if dochild is None or dochild:
                for child in n.parts:
                    self.visit(child)
            # TODO
            return n
        elif k == "redirect":
            dochild = self._visitnode(n, n.input, n.type, n.output, n.heredoc)
            if dochild is None or dochild:
                if isinstance(n.output, ast.node):
                    self.visit(n.output)
                if n.heredoc:
                    self.visit(n.heredoc)
            # TODO
            return n
        elif k == "word":
            dochild = self._visitnode(n, n.word)
            if dochild == n:
                for child in n.parts:
                    self.visit(child)
                # TODO
                return n
            else:
                return dochild
        elif k == "assignment":
            dochild = self._visitnode(n, n.word)
            if dochild is None or dochild:
                for child in n.parts:
                    self.visit(child)
            # TODO
            return n
        elif k in ("parameter", "tilde", "heredoc"):
            return self._visitnode(n, n.value)
        elif k in ("commandsubstitution", "processsubstitution"):
            dochild = self._visitnode(n, n.command)
            if dochild is None or dochild:
                self.visit(n.command)
            # TODO
            return n
        else:
            raise ValueError("unknown node kind %r" % k)
        return self.visitnodeend(n)


lines = []
trees = []
with open(sys.argv[1], "r") as f:
    lines = f.readlines()

for line in lines:
    input = line.strip()
    # bashlex barfs on empty lines
    if len(input) == 0:
        continue
    trees += parser.parse(input)

for i in range(len(trees)):
    pv = prettyprinter()
    print("line: " + lines[i].strip())

    # print before
    print("before: ")
    pv.visit(trees[i])

    # do substitutions
    visitor = substitutionvisitor()
    tree2 = visitor.visit(trees[i])

    # print after
    print("after: ")
    pv.visit(tree2)

    print("-------")

print(env)
